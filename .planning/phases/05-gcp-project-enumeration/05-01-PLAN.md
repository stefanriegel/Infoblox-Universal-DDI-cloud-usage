---
phase: 05-gcp-project-enumeration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - gcp_discovery/config.py
  - requirements.txt
autonomous: true
requirements: [ENUM-01, ENUM-02, ENUM-03, ENUM-04, ENUM-05, ENUM-06]

must_haves:
  truths:
    - "enumerate_gcp_projects() with no explicit project fetches all ACTIVE projects via search_projects and returns a list of ProjectInfo"
    - "enumerate_gcp_projects() with an explicit project bypasses search_projects and returns a single-element ProjectInfo list"
    - "When zero projects are found, an actionable error mentioning resourcemanager.projects.get is printed and sys.exit(1) is called"
    - "When org_id is provided, search_projects query is scoped to parent:organizations/{org_id}"
    - "Include/exclude glob patterns filter the project list before API pre-checks"
    - "Per-project API pre-check sets compute_enabled and dns_enabled booleans on each ProjectInfo"
    - "Projects with disabled APIs get [Skip] log lines; projects with all APIs enabled are silent"
    - "google-cloud-resource-manager and google-cloud-service-usage are in requirements.txt"
  artifacts:
    - path: "gcp_discovery/config.py"
      provides: "ProjectInfo dataclass and enumerate_gcp_projects() function"
      contains: "class ProjectInfo"
    - path: "gcp_discovery/config.py"
      provides: "Project enumeration via search_projects"
      contains: "enumerate_gcp_projects"
    - path: "requirements.txt"
      provides: "New GCP dependencies"
      contains: "google-cloud-resource-manager"
  key_links:
    - from: "gcp_discovery/config.py:enumerate_gcp_projects()"
      to: "resourcemanager_v3.ProjectsClient.search_projects()"
      via: "_fetch_active_projects() helper"
      pattern: "search_projects"
    - from: "gcp_discovery/config.py:enumerate_gcp_projects()"
      to: "service_usage_v1.ServiceUsageClient.batch_get_services()"
      via: "_check_apis_enabled() helper"
      pattern: "batch_get_services"
    - from: "gcp_discovery/config.py:enumerate_gcp_projects()"
      to: "fnmatch.fnmatch()"
      via: "_apply_project_filters() helper"
      pattern: "fnmatch"
---

<objective>
Add the core GCP project enumeration logic to config.py: a `ProjectInfo` dataclass, `enumerate_gcp_projects()` function with single-project bypass, multi-project enumeration via search_projects, org scoping, glob filtering, and per-project API availability pre-checks. Also add new dependencies to requirements.txt.

Purpose: Phase 5 builds the curated project list that Phase 6 consumes for concurrent multi-project discovery. All enumeration, filtering, and pre-checking happens here — discover.py and main.py just call `enumerate_gcp_projects()` with the right arguments.

Output: Updated `gcp_discovery/config.py` with `ProjectInfo`, `enumerate_gcp_projects()`, and all supporting helpers. Updated `requirements.txt` with two new GCP packages.
</objective>

<execution_context>
@/Users/sr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-gcp-project-enumeration/05-RESEARCH.md
@gcp_discovery/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ProjectInfo dataclass, enumeration helpers, and enumerate_gcp_projects() to config.py</name>
  <files>gcp_discovery/config.py</files>
  <action>
Add the following to `gcp_discovery/config.py`:

1. **Imports** — Add at the top of the file (after existing imports):
   - `from dataclasses import dataclass`
   - `import fnmatch` (stdlib)
   - No new third-party imports at module level. The `resourcemanager_v3` and `service_usage_v1` imports go inside the functions that use them (deferred imports, same pattern as `_check_gcp_compute_permission()`).

2. **ProjectInfo dataclass** — Add after the credential singleton variables but before `get_gcp_credential()`:
   ```python
   @dataclass
   class ProjectInfo:
       project_id: str
       compute_enabled: bool
       dns_enabled: bool
   ```

3. **`_fetch_active_projects(credentials, org_id: Optional[str]) -> List[str]`** — Add after `_fail_gcp_auth()`:
   - Import `resourcemanager_v3` inside the function body (deferred).
   - Create `ProjectsClient(credentials=credentials)`.
   - Build query: `"state:ACTIVE"` when org_id is None; `f"state:ACTIVE parent:{parent}"` when org_id is set (normalize org_id: if it starts with `"organizations/"` use as-is, else prepend `"organizations/"`).
   - Iterate `client.search_projects(request=SearchProjectsRequest(query=query))`.
   - Defense-in-depth: only append `project.project_id` if `project.state == resourcemanager_v3.Project.State.ACTIVE`.
   - Catch `api_exceptions.PermissionDenied` from the `search_projects` call itself — print actionable error: `"ERROR: Cannot enumerate GCP projects. Ensure cloudresourcemanager.googleapis.com is enabled and the credential has resourcemanager.projects.get permission."` then `sys.exit(1)`. Import `api_exceptions` from `google.api_core` inside the function.
   - Return `List[str]` of project IDs.

4. **`_apply_project_filters(project_ids, include_patterns, exclude_patterns) -> List[str]`** — Add after `_fetch_active_projects`:
   - If `include_patterns` is not None, keep only projects matching at least one pattern via `fnmatch.fnmatch(p, pat)`.
   - If `exclude_patterns` is not None, remove projects matching any pattern.
   - Return filtered list.

5. **`_check_apis_enabled(credentials, project_id: str) -> Tuple[bool, bool]`** — Add after `_apply_project_filters`:
   - Import `service_usage_v1` from `google.cloud` inside the function body (deferred).
   - Import `api_exceptions` from `google.api_core` inside the function body.
   - Create `ServiceUsageClient(credentials=credentials)`.
   - Call `batch_get_services` with `parent=f"projects/{project_id}"` and `names=[f"projects/{project_id}/services/compute.googleapis.com", f"projects/{project_id}/services/dns.googleapis.com"]`.
   - Parse response: check `svc.state == service_usage_v1.types.Service.State.ENABLED` for each service.
   - On `api_exceptions.PermissionDenied`: return `(False, False)` — treat as both APIs unavailable (this is the `accessNotConfigured` case per ENUM-06).
   - On any other `Exception`: return `(True, True)` — assume enabled, let discovery surface the real error later.
   - Return `(compute_enabled, dns_enabled)`.

6. **`_log_api_status(project_id: str, compute_enabled: bool, dns_enabled: bool) -> None`** — Add after `_check_apis_enabled`:
   - If not `compute_enabled`: `print(f"[Skip] {project_id}: Compute API disabled")`
   - If not `dns_enabled`: `print(f"[Skip] {project_id}: DNS API disabled")`
   - Silent for fully-enabled projects (per locked decision).

7. **`enumerate_gcp_projects(credentials, adc_project, project, org_id, include_patterns, exclude_patterns) -> List[ProjectInfo]`** — Add after `_log_api_status`. Signature uses explicit keyword arguments rather than an args namespace for testability:
   - **Parameters:** `credentials` (the validated credential object), `adc_project: Optional[str]` (project from ADC), `project: Optional[str]` (explicit --project flag value), `org_id: Optional[str]` (from --org-id flag or GOOGLE_CLOUD_ORG_ID), `include_patterns: Optional[List[str]]`, `exclude_patterns: Optional[List[str]]`.
   - **Priority logic (Claude's Discretion — flag > env var > ADC):**
     - `explicit_project = project or os.getenv("GOOGLE_CLOUD_PROJECT") or adc_project`
     - Per GCP SDK convention, CLI flag always wins over env var, which wins over ADC-inferred project.
   - **Single-project path (ENUM-03):** If `explicit_project` is truthy, bypass enumeration. Call `_check_apis_enabled(credentials, explicit_project)`, call `_log_api_status()`, return `[ProjectInfo(project_id=explicit_project, compute_enabled=compute_ok, dns_enabled=dns_ok)]`.
   - **Multi-project path:** Call `_fetch_active_projects(credentials, org_id)`. Then call `_apply_project_filters(project_ids, include_patterns, exclude_patterns)`. If result is empty, print `"ERROR: No ACTIVE GCP projects found. Ensure the credential has resourcemanager.projects.get permission."` and `sys.exit(1)` (ENUM-02). Print `f"Found {len(project_ids)} ACTIVE projects"` (ENUM-01, locked decision: count only, not full list, printed before pre-checks). Loop through projects, call `_check_apis_enabled` and `_log_api_status` for each, build `ProjectInfo` list. Return list.

**Important implementation notes:**
- Do NOT create `ServiceUsageClient` or `ProjectsClient` per project in the pre-check loop — create one instance before the loop and reuse it. Pass the client to `_check_apis_enabled` (add a `client` parameter) or create clients once inside `enumerate_gcp_projects` and call the batch API directly in the loop (research anti-pattern note).
- The `Tuple` import needs to be added to the typing imports at the top.
  </action>
  <verify>
Verify by structural inspection:
1. `grep -n "class ProjectInfo" gcp_discovery/config.py` — dataclass exists
2. `grep -n "def enumerate_gcp_projects" gcp_discovery/config.py` — function exists
3. `grep -n "def _fetch_active_projects" gcp_discovery/config.py` — helper exists
4. `grep -n "def _apply_project_filters" gcp_discovery/config.py` — helper exists
5. `grep -n "def _check_apis_enabled" gcp_discovery/config.py` — helper exists
6. `grep -n "def _log_api_status" gcp_discovery/config.py` — helper exists
7. `grep -n "search_projects" gcp_discovery/config.py` — uses correct API method
8. `grep -n "batch_get_services" gcp_discovery/config.py` — uses correct API method
9. `grep -n "fnmatch" gcp_discovery/config.py` — uses fnmatch for glob filtering
10. `grep -n "sys.exit" gcp_discovery/config.py` — zero-project case exits
11. `grep "ACTIVE projects" gcp_discovery/config.py` — print count line present
12. `grep "\[Skip\]" gcp_discovery/config.py` — disabled API log lines present
13. Verify no bare `except Exception` wrapping auth/credential code (CRED-05 from Phase 4)
14. Run `python3 -c "import ast; ast.parse(open('gcp_discovery/config.py').read()); print('Syntax OK')"` to verify no syntax errors
  </verify>
  <done>
gcp_discovery/config.py contains ProjectInfo dataclass, enumerate_gcp_projects() with single-project bypass (ENUM-03), multi-project enumeration (ENUM-01), org scoping (ENUM-04), glob filtering (ENUM-05), zero-project error with IAM hint (ENUM-02), per-project API pre-check with [Skip] logging (ENUM-06), and all helper functions. No new module-level imports of google-cloud-resource-manager or google-cloud-service-usage (deferred inside functions).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add google-cloud-resource-manager and google-cloud-service-usage to requirements.txt</name>
  <files>requirements.txt</files>
  <action>
Add two new lines to the `# GCP Dependencies` section of `requirements.txt`, after the existing GCP entries:

```
google-cloud-resource-manager>=1.12.0
google-cloud-service-usage>=1.3.0
```

Place them after the `google-auth>=2.17.0` line, before the `# Common Dependencies` section. Maintain the existing file formatting (no trailing whitespace, blank line before next section header).
  </action>
  <verify>
1. `grep "google-cloud-resource-manager" requirements.txt` — line present with `>=1.12.0`
2. `grep "google-cloud-service-usage" requirements.txt` — line present with `>=1.3.0`
3. Verify no duplicate entries: `grep -c "google-cloud-resource-manager" requirements.txt` should output `1`
  </verify>
  <done>
requirements.txt contains google-cloud-resource-manager>=1.12.0 and google-cloud-service-usage>=1.3.0 in the GCP Dependencies section.
  </done>
</task>

</tasks>

<verification>
1. `gcp_discovery/config.py` parses without syntax errors (`python3 -c "import ast; ast.parse(open('gcp_discovery/config.py').read())"`)
2. `ProjectInfo` dataclass has fields: `project_id: str`, `compute_enabled: bool`, `dns_enabled: bool`
3. `enumerate_gcp_projects()` handles all six ENUM requirements
4. `requirements.txt` has both new GCP dependencies
5. No circular imports introduced (all new GCP library imports are deferred inside function bodies)
6. Existing `get_gcp_credential()`, `GCPConfig`, `get_all_gcp_regions()`, `validate_gcp_config()` are unchanged
</verification>

<success_criteria>
- ProjectInfo dataclass and enumerate_gcp_projects() exist in config.py
- Single-project bypass path works (flag > env var > ADC priority)
- Multi-project path calls search_projects with correct query
- Org scoping builds correct parent filter
- Glob filtering uses fnmatch
- Zero-project error mentions resourcemanager.projects.get and exits
- API pre-check uses batch_get_services and logs [Skip] for disabled APIs
- requirements.txt has both new packages
</success_criteria>

<output>
After completion, create `.planning/phases/05-gcp-project-enumeration/05-01-SUMMARY.md`
</output>
