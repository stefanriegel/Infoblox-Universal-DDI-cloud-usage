---
phase: 04-gcp-credential-chain-and-fail-fast
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - gcp_discovery/config.py
autonomous: true
requirements:
  - CRED-01
  - CRED-02
  - CRED-04
  - CRED-05

must_haves:
  truths:
    - "get_gcp_credential() returns a validated (credentials, project) tuple from a module-level singleton protected by threading.Lock"
    - "Calling get_gcp_credential() with invalid or missing credentials prints an actionable error with both SA and ADC remediation paths and exits non-zero"
    - "Calling get_gcp_credential() with expired credentials prints an actionable error mentioning token refresh and exits non-zero"
    - "After successful authentication, an [Auth] log line is printed identifying the credential type and default project"
    - "A lightweight compute API call validates permissions before returning the credential — PermissionDenied exits with IAM guidance"
    - "GCPConfig._get_default_project_id() no longer calls gcloud subprocess — returns env var only"
  artifacts:
    - path: "gcp_discovery/config.py"
      provides: "GCP credential singleton with validation, logging, and permission pre-check"
      contains: "_gcp_credential_cache"
      contains_also: "_gcp_credential_lock"
      contains_also2: "_build_gcp_credential"
  key_links:
    - from: "gcp_discovery/config.py:get_gcp_credential()"
      to: "gcp_discovery/config.py:_build_gcp_credential()"
      via: "double-checked locking with _gcp_credential_lock"
      pattern: "_gcp_credential_cache = _build_gcp_credential"
    - from: "gcp_discovery/config.py:_build_gcp_credential()"
      to: "google.auth.default()"
      via: "credential discovery"
      pattern: "credentials, project = default"
    - from: "gcp_discovery/config.py:_build_gcp_credential()"
      to: "credentials.refresh(Request())"
      via: "token validation"
      pattern: "credentials\\.refresh"
---

<objective>
Build the GCP credential singleton in config.py — the validated, thread-safe credential provider that all GCP discovery code will use.

Purpose: Replace the broken `get_gcp_credential()` (no validation, wraps DefaultCredentialsError in bare Exception) and `_get_default_project_id()` (gcloud subprocess fallback) with a production-quality singleton modeled on the Azure credential pattern.

Output: A rewritten `gcp_discovery/config.py` where `get_gcp_credential()` returns a validated `(credentials, project)` tuple from a thread-safe singleton, logs the credential type at startup, pre-checks compute permissions, and exits with actionable guidance on any auth failure.
</objective>

<execution_context>
@/Users/sr/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-gcp-credential-chain-and-fail-fast/04-RESEARCH.md
@.planning/phases/04-gcp-credential-chain-and-fail-fast/04-CONTEXT.md
@gcp_discovery/config.py
@azure_discovery/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite get_gcp_credential() as validated singleton with auth logging and permission pre-check</name>
  <files>gcp_discovery/config.py</files>
  <action>
Rewrite `get_gcp_credential()` and add supporting functions in `gcp_discovery/config.py`. Follow the Azure singleton pattern from `azure_discovery/config.py` exactly.

**Add imports at top of file:**
- `import sys`
- `import threading`
- `from google.auth import default` (already imported)
- `from google.auth.exceptions import DefaultCredentialsError, RefreshError` (DefaultCredentialsError already imported, add RefreshError)
- `from google.auth.transport.requests import Request`
- `from google.oauth2 import service_account`
- `import google.oauth2.credentials`
- `import google.auth.compute_engine`

**Add module-level singleton variables** (before the GCPConfig class):
```python
_gcp_credential_cache = None  # Tuple of (credentials, project)
_gcp_credential_lock = threading.Lock()
```

**Replace the existing `get_gcp_credential()` function** with the double-checked locking singleton pattern:
```python
def get_gcp_credential():
    """Return validated (credentials, project) singleton. Exits on auth failure."""
    global _gcp_credential_cache
    if _gcp_credential_cache is not None:
        return _gcp_credential_cache
    with _gcp_credential_lock:
        if _gcp_credential_cache is not None:
            return _gcp_credential_cache
        _gcp_credential_cache = _build_gcp_credential()
        return _gcp_credential_cache
```

**Add `_build_gcp_credential()` function** that does the actual work:
1. Call `credentials, project = default()` — catch `DefaultCredentialsError`, call `_fail_gcp_auth()` with `include_both_paths=True`
2. Call `credentials.refresh(Request())` — catch `RefreshError`, call `_fail_gcp_auth()` with refresh-specific message
3. Call `_log_gcp_credential_type(credentials, project)` for CRED-04
4. Call `_check_gcp_compute_permission(credentials, project)` for permission pre-check (locked decision)
5. Return `(credentials, project)`

**Add `_log_gcp_credential_type(credentials, project)` function:**
- `isinstance(credentials, service_account.Credentials)` -> print `[Auth] Using service account: {email}{project_info}` where email = `credentials.service_account_email`
- `isinstance(credentials, google.oauth2.credentials.Credentials)` -> print `[Auth] Using Application Default Credentials{project_info}` (covers both ADC user and gcloud auth login)
- `isinstance(credentials, google.auth.compute_engine.Credentials)` -> print `[Auth] Using Application Default Credentials (Compute Engine){project_info}`
- else -> print `[Auth] Using Application Default Credentials ({type(credentials).__name__}){project_info}` (covers Workload Identity Federation etc.)
- Where `project_info = f" (default project: {project})" if project else ""`
- Per locked decision: Auth log line must include default project when known.

**Add `_check_gcp_compute_permission(credentials, project)` function:**
- If `project` is None, return silently (no project to check against; discovery will fail later with a clear message)
- Try: create `compute_v1.RegionsClient(credentials=credentials)`, call `next(iter(client.list(project=project)), None)`
- Catch permission/forbidden errors (use `google.api_core.exceptions`): `PermissionDenied` -> print error with IAM role guidance (`roles/compute.viewer`), `sys.exit(1)`; `Forbidden` -> print error suggesting Compute API enablement (`gcloud services enable compute.googleapis.com --project=...`), `sys.exit(1)`
- Other exceptions (network, 429) are transient — let them pass silently; discovery will handle them.
- Import `compute_v1` and `api_exceptions` inside the function to avoid circular imports and keep it self-contained.

**Add `_fail_gcp_auth(message, include_both_paths=False)` function** that prints actionable error and exits:
- Print `ERROR: {message}`
- When `include_both_paths=True` (DefaultCredentialsError — nothing found): show both SA and ADC options equally, per locked decision. Include "No ADC found. If you have gcloud configured, run: `gcloud auth application-default login`"
- When `include_both_paths=False` (RefreshError — found but expired): show both fix paths (ADC refresh and SA key set)
- Always show project setup hint: `export GOOGLE_CLOUD_PROJECT=my-project-id`
- Call `sys.exit(1)`

**Exception discipline (CRED-05):** The only exception types caught in `_build_gcp_credential()` are `DefaultCredentialsError` and `RefreshError`. No bare `except Exception`. The `_check_gcp_compute_permission()` catches `PermissionDenied` and `Forbidden` from `google.api_core.exceptions` — these are API errors, not auth chain errors.
  </action>
  <verify>
Run `python -c "from gcp_discovery.config import get_gcp_credential, _gcp_credential_cache, _gcp_credential_lock; print('imports OK')"` to verify the module loads without syntax errors and exports the singleton variables.

Verify no `subprocess` import remains in the credential functions by searching config.py for `subprocess`.

Verify `DefaultCredentialsError` and `RefreshError` are the only exception types caught in `_build_gcp_credential()` — no bare `except Exception`.
  </verify>
  <done>
`get_gcp_credential()` is a thread-safe singleton that validates credentials via `refresh(Request())`, logs the credential type with project info via `[Auth]` line, pre-checks compute permissions, and exits with actionable guidance on any auth failure. Only typed exceptions are caught in the credential chain.
  </done>
</task>

<task type="auto">
  <name>Task 2: Remove gcloud subprocess from GCPConfig._get_default_project_id()</name>
  <files>gcp_discovery/config.py</files>
  <action>
Replace `GCPConfig._get_default_project_id()` to remove the gcloud subprocess fallback. Per locked decision: eliminate ALL gcloud subprocess calls for authentication.

**Replace the entire `_get_default_project_id()` method** with:
```python
def _get_default_project_id(self) -> Optional[str]:
    """Get default project ID from environment variable.

    The project is also returned by get_gcp_credential() from the ADC chain.
    GCPDiscovery._init_gcp_clients() merges both sources.
    """
    return os.getenv("GOOGLE_CLOUD_PROJECT")
```

This removes:
- The `import subprocess` inside the function body
- The `subprocess.run(["gcloud", "config", "get-value", "project"])` call
- The `"default-project"` hardcoded fallback (which was misleading — it's not a real project)

The return type changes from `str` (always returned something) to `Optional[str]` (returns None when env var not set). This is correct because `GCPDiscovery._init_gcp_clients()` already handles this with `self.project_id = project or self.gcp_config.project_id`, where `project` comes from `get_gcp_credential()`.

**Remove the top-level `import subprocess`** if it exists (check if any other function in config.py still needs it). After this task, no function in config.py should use subprocess.

**Update `GCPConfig.__init__`** if needed: the `project_id` parameter is `Optional[str]`, and `_get_default_project_id()` now returns `Optional[str]`. The line `self.project_id = project_id or self._get_default_project_id()` may now set `self.project_id` to `None`. This is acceptable — `GCPDiscovery._init_gcp_clients()` fills it from the credential.
  </action>
  <verify>
Run `python -c "from gcp_discovery.config import GCPConfig; print('GCPConfig loads OK')"` to verify no import errors.

Search config.py for `subprocess` — should return zero matches.

Search config.py for `"default-project"` — should return zero matches.
  </verify>
  <done>
`GCPConfig._get_default_project_id()` returns only the `GOOGLE_CLOUD_PROJECT` environment variable (or None). No gcloud subprocess calls remain in config.py. The misleading `"default-project"` hardcoded fallback is removed.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from gcp_discovery.config import get_gcp_credential"` succeeds without errors
2. `grep -n "subprocess" gcp_discovery/config.py` returns no matches
3. `grep -n "except Exception" gcp_discovery/config.py` returns no matches in credential functions (may exist in `get_all_gcp_regions()` fallback — that is acceptable per research)
4. `grep -n "_gcp_credential_cache" gcp_discovery/config.py` shows singleton variable and double-checked locking pattern
5. `grep -n "\[Auth\]" gcp_discovery/config.py` shows credential type logging for SA, ADC, and Compute Engine paths
6. `grep -n "sys.exit" gcp_discovery/config.py` shows fail-fast exits in `_fail_gcp_auth()` and `_check_gcp_compute_permission()`
7. `grep -n "default-project" gcp_discovery/config.py` returns no matches
</verification>

<success_criteria>
- config.py contains a thread-safe credential singleton with double-checked locking
- Token validation via `credentials.refresh(Request())` happens inside the singleton builder
- Credential type is logged with `[Auth]` prefix including default project when known
- Permission pre-check via compute API call exits with IAM guidance on PermissionDenied
- Actionable error messages show both SA and ADC remediation paths on auth failure
- No gcloud subprocess calls remain in config.py
- Only typed exceptions (DefaultCredentialsError, RefreshError) are caught in credential chain
</success_criteria>

<output>
After completion, create `.planning/phases/04-gcp-credential-chain-and-fail-fast/04-01-SUMMARY.md`
</output>
